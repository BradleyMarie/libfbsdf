#include "libfbsdf/test_bsdf_writer.h"

#include <algorithm>
#include <bit>
#include <cstddef>
#include <cstdint>
#include <limits>
#include <stdexcept>
#include <string>
#include <vector>

namespace libfbsdf {
namespace testing {
namespace {

void WriteUInt32(std::string& output, uint32_t value) {
  if constexpr (std::endian::native != std::endian::little) {
    value = std::byteswap(value);
  }

  const char* bytes = reinterpret_cast<const char*>(&value);
  output += bytes[0];
  output += bytes[1];
  output += bytes[2];
  output += bytes[3];
}

void WriteFloat(std::string& output, float value) {
  WriteUInt32(output, std::bit_cast<uint32_t>(value));
}

}  // namespace

BsdfData::BsdfData(std::vector<float> elevational_samples,
                   size_t num_basis_functions, size_t num_channels)
    : elevational_samples_(std::move(elevational_samples)),
      series_(elevational_samples_.size() * elevational_samples_.size()),
      cdf_(elevational_samples_.size() * elevational_samples_.size() *
               num_basis_functions,
           0.0f),
      num_basis_functions_(num_basis_functions),
      num_channels_(num_channels) {
  for (auto& list : series_) {
    for (size_t i = 0; i < num_basis_functions; i++) {
      for (size_t j = 0; j < num_channels; j++) {
        list.emplace_back();
      }
    }
  }
}

void BsdfData::AddCoefficient(size_t basis_function, size_t channel,
                              size_t sample_x, size_t sample_y, float value) {
  series_.at(sample_y * elevational_samples_.size() + sample_x)
      .at(basis_function * num_channels_ + channel)
      .push_back(value);
}

BsdfData::Coefficients BsdfData::SerializeCoefficients() const {
  BsdfData::Coefficients result;
  result.max_order = 0;
  for (const auto& list : series_) {
    if (list.empty()) {
      continue;
    }

    size_t num_coefficients = list[0].size();
    result.max_order = std::max(result.max_order, num_coefficients);
    result.bounds.push_back(result.coefficients.size());
    result.bounds.push_back(num_coefficients);

    for (const auto& channel : list) {
      if (channel.size() != num_coefficients) {
        throw std::logic_error(
            "all channels must have the same number of coefficients");
      }

      result.coefficients.insert(result.coefficients.end(), channel.begin(),
                                 channel.end());
    }
  }
  return result;
}

void BsdfData::SetCdf(size_t basis_function, size_t sample_x, size_t sample_y,
                      float value) {
  size_t span_size = elevational_samples_.size() * elevational_samples_.size();
  cdf_.at(span_size * basis_function + sample_y * elevational_samples_.size() +
          sample_x) = value;
}

std::string MakeBsdfFile(const Flags& flags, const BsdfData& bsdf_data,
                         std::vector<uint32_t> parameter_sample_counts,
                         std::vector<float> parameters, std::string metadata,
                         float index_of_refraction, float roughness_top,
                         float roughness_bottom) {
  BsdfData::Coefficients coefficients = bsdf_data.SerializeCoefficients();

  std::string result;

  // identifier
  result += 'S';
  result += 'C';
  result += 'A';
  result += 'T';
  result += 'F';
  result += 'U';
  result += 'N';

  // version
  result += '\1';

  // flags
  char is_bsdf = flags.is_bsdf ? '\1' : '\0';
  char uses_harmonic_extrapolation =
      flags.uses_harmonic_extrapolation ? '\2' : '\0';

  result += is_bsdf | uses_harmonic_extrapolation;
  result += '\0';
  result += '\0';
  result += '\0';

  // nNodes
  WriteUInt32(result, bsdf_data.GetElevationalSamples().size());

  // nCoeffs
  WriteUInt32(result, coefficients.coefficients.size());

  // nMaxOrder
  WriteUInt32(result, coefficients.max_order);

  // nChannels
  WriteUInt32(result, bsdf_data.GetNumChannels());

  // nBases
  WriteUInt32(result, bsdf_data.GetNumBasisFunctions());

  // nMetadataBytes
  WriteUInt32(result, metadata.size());

  // nParameters
  WriteUInt32(result, parameter_sample_counts.size());

  // nParameterValues
  WriteUInt32(result, parameters.size());

  // eta
  WriteFloat(result, index_of_refraction);

  // roughness
  WriteFloat(result, roughness_top);
  WriteFloat(result, roughness_bottom);

  // reserved
  result += '\0';
  result += '\0';
  result += '\0';
  result += '\0';
  result += '\0';
  result += '\0';
  result += '\0';
  result += '\0';

  for (float f : bsdf_data.GetElevationalSamples()) {
    WriteFloat(result, f);
  }

  for (uint32_t u : parameter_sample_counts) {
    WriteUInt32(result, u);
  }

  for (float f : parameters) {
    WriteFloat(result, f);
  }

  for (float f : bsdf_data.GetCdf()) {
    WriteFloat(result, f);
  }

  for (uint32_t u : coefficients.bounds) {
    WriteUInt32(result, u);
  }

  for (float f : coefficients.coefficients) {
    WriteFloat(result, f);
  }

  for (char c : metadata) {
    result += c;
  }

  return result;
}

std::string MakeEmptyBsdfFile(float index_of_refraction, float roughness_top,
                              float roughness_bottom) {
  BsdfData data(std::vector<float>(), 0, 0);

  Flags flags{.is_bsdf = true, .uses_harmonic_extrapolation = false};

  return MakeBsdfFile(flags, data, {}, {}, "", index_of_refraction,
                      roughness_top, roughness_bottom);
}

std::string MakeMinimalBsdfFile(float index_of_refraction, float roughness_top,
                                float roughness_bottom) {
  BsdfData data(std::vector<float>({1.0f}), 1, 1);
  data.AddCoefficient(0, 0, 0, 1.0f);
  data.SetCdf(0, 0, 0, 0.0f);

  Flags flags{.is_bsdf = true, .uses_harmonic_extrapolation = false};

  return MakeBsdfFile(flags, data, {1}, {1.0f}, "meta", index_of_refraction,
                      roughness_top, roughness_bottom);
}

std::string MakeNonFiniteBsdfFile(float index_of_refraction,
                                  float roughness_top, float roughness_bottom) {
  BsdfData data(std::vector<float>({std::numeric_limits<float>::quiet_NaN()}),
                1, 1);
  data.AddCoefficient(0, 0, 0, std::numeric_limits<float>::quiet_NaN());
  data.SetCdf(0, 0, 0, std::numeric_limits<float>::quiet_NaN());

  Flags flags{.is_bsdf = true, .uses_harmonic_extrapolation = false};

  return MakeBsdfFile(flags, data, {1},
                      {std::numeric_limits<float>::quiet_NaN()}, "meta",
                      index_of_refraction, roughness_top, roughness_bottom);
}

}  // namespace testing
}  // namespace libfbsdf
